# systemcheck

A tiny Rust CLI that prints CPU, memory, and cgroup constraints for your current process. It’s especially useful in containerized or resource‑constrained environments (Docker, Kubernetes, Slurm) and interactive platforms like Posit Workbench, where your session may see fewer CPUs and less memory than the host machine.

## Why use this?
- See the difference between real machine resources and what your session/container is allowed to use.
- Quickly diagnose “why is this slow?” by checking CPU quotas and memory limits applied via cgroups.
- Works well inside Posit Workbench: open a terminal in your session and run `systemcheck` to inspect your resource limits.

## What it reports
- CPU
  - System Logical CPUs (threads) and Physical CPUs (cores)
  - Available CPUs (respecting cgroup limits)
  - CGroup CPU Quota (derived from cgroup v1/v2)
- Memory
  - System Total/Available/Used (from `/proc/meminfo`)
  - CGroup Memory Limit and current usage (v1/v2 aware)
- CGroup
  - Detected cgroup version (v1 or v2)
  - Current process cgroup lines from `/proc/self/cgroup`
  - Resource constraints for the current cgroup (CPU quota, memory limit)

## Example output
```
$systemcheck
=== System Check - Resource Diagnostics ===

CPU Information:
----------------
  System Logical CPUs:     4 threads
  System Physical CPUs:    2 cores
  Available CPUs (cgroup): 3
  ⚠️  CPU is constrained by cgroups to 3 of 4 system CPUs
  CGroup CPU Quota:        3.00 CPUs

Memory Information:
-------------------
  System Total Memory:     30.6 GiB
  System Available Memory: 27.4 GiB
  System Used Memory:      3.1 GiB
  CGroup Memory Limit:     12 GiB
  ⚠️  Memory is constrained by cgroups!
  CGroup Memory Usage:     1 GiB (8.9% of limit)

CGroup Information:
-------------------
  CGroup Version: v2 (unified hierarchy)
  Current Process CGroups:
    0::/system.slice/rstudio-launcher.service/jobs/BdjJQoPrO1B8dD8BEqnJhA==

  Resource Constraints for Current CGroup:
    CPU Quota: 3.00 CPUs
    Memory Limit: 12 GiB
```

Note: Actual numbers depend on your system and container limits.

## Build and run
- Prerequisite: Rust toolchain (stable). Install from https://rustup.rs
- Build
  - Debug: `cargo build`
  - Release: `cargo build --release`
- Run
  - Debug: `cargo run`
  - Release: `./target/release/systemcheck`

## Install (prebuilt binaries)
You can install with a one-liner generated by cargo-dist.
By default, the script installer will install to `$XDG_BIN_HOME` if set, otherwise `~/.local/bin`.

- Latest release (auto-selects your Linux architecture):
  - bash
    - `curl -fsSL https://github.com/A2-ai/systemcheck/releases/latest/download/systemcheck-installer.sh | sh`
- Specific version (replace v0.1.2 with the tag you want):
  - bash
    - `curl -fsSL https://github.com/A2-ai/systemcheck/releases/download/v0.1.2/systemcheck-installer.sh | sh`

This installs the binary into a standard location (`$XDG_BIN_HOME` or `~/.local/bin`). Ensure this dir is on your PATH.

### Install to ~/.local/bin explicitly
If you want to force installation to `~/.local/bin` (and avoid modifying your shell rc files), set these env vars for the installer:

- Latest release:
  - bash
    - `curl -fsSL https://github.com/A2-ai/systemcheck/releases/latest/download/systemcheck-installer.sh | env CARGO_DIST_INSTALL_DIR="$HOME/.local" CARGO_DIST_NO_MODIFY_PATH=1 sh`
- Specific version:
  - bash
    - `curl -fsSL https://github.com/A2-ai/systemcheck/releases/download/v0.1.2/systemcheck-installer.sh | env CARGO_DIST_INSTALL_DIR="$HOME/.local" CARGO_DIST_NO_MODIFY_PATH=1 sh`

Notes:
- `CARGO_DIST_INSTALL_DIR="$HOME/.local"` makes the installer place the binary at `$HOME/.local/bin/systemcheck`.
- `CARGO_DIST_NO_MODIFY_PATH=1` prevents editing your rc files; ensure `~/.local/bin` is on PATH (many distros set this by default).
- As an alternative, you can use `UNMANAGED_INSTALL="$HOME/.local/bin"` to install in a flat layout directly into that directory.

## How it works
- Reads Linux procfs and cgroup files:
  - `/proc/cpuinfo`, `/proc/meminfo`, `/proc/self/cgroup`
  - `/sys/fs/cgroup/**` for cgroup v1 and v2
- Falls back gracefully when files aren’t present or limits are “unlimited”.

## Troubleshooting
- Missing values usually mean files aren’t present (e.g., not running on Linux or limited access in the environment).
- If output looks odd in a container, verify your runtime is using cgroup v1 vs v2; the tool checks both and reports whichever is available.
